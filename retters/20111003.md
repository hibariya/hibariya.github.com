# モジュール関数がprivateな理由

[モジュール関数](http://rurema.clear-code.com/1.9.2/method/Module/i/module_function.html)
というものがあって、ぼくはこれまでモジュール関数を「モジュールをレシーバにしても呼び出せるしincludeして呼び出すこともできる何だか便利なもの」としか認識していなかった。

こういうふうに。

~~~~ruby
  module MyModule
    extend self

    def greet
      'fart'
    end
  end

  MyModule.greet   # => "fart"

  include MyModule
  greet            # => "fart"
  self.greet       # => "fart"
~~~~

でもこれはモジュール関数じゃなかった。

るりまの説明をよく見てみると「モジュール関数とは、プライベートメソッドであると同時に モジュールの特異メソッドでもあるようなメソッドです。」と書いてある。ぎぎぎ何だか面倒くさいな。

Rubyでprivateメソッドと言えば、呼び出しのときにレシーバを指定できないメソッドのことを指す。試しに、よく例に使われる`Math.#sqrt`で確認してみる。

~~~~ruby
  Math.sqrt(100) # => 10.0

  include Math
  sqrt(100)      # => 10.0
  self.sqrt(100) # => NoMethodError: private method `sqrt' called for ...
~~~~

うげげ、本当だ。今まで知らずに使っていたけれど、きみはprivateだったのか。なんで？

その後何日間もこのことで悩み続けてしまったのだけど、敗因は「モジュール関数がprivateメソッドとはどういうことだろう」と考えてしまっていたからだった。
「*関数*にレシーバがないのは自然だなあ」と思えたら何も悩むことはなかったのだけど。

モジュール関数は実際はメソッドだけど、あくまで関数のように使うためのものなのだった。

Rubyには関数風メソッドやモジュール関数とよばれるものが存在するけど、厳密には関数は存在しない。
モジュール関数がprivateなのは、メソッドでありながら、レシーバを意識しない「関数」のようなものになるためだった。
モジュール関数はprivateなので、レシーバは自動的にselfになるけど、その関数とselfの間にはなんの関わりもない（ものとして実装されるべき）。

確かに「関数」と名前がついているものにレシーバがあるほうがよっぽどおかしい。
関数だと思って使ってたのに、突然`self.sqrt(pya)`とかやられた日にはびっくりしてしまう。ということを理解するのにかなり時間がかかったというお話でした。


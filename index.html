<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Joy Luck Crab</title>
<meta content="hibariya" name="author">
<link href="./favicon.png" rel="icon" type="image/png">
<link href="./stylesheets/base.css" media="screen" rel="stylesheet" type="text/css">
<link href="./stylesheets/orange.css" media="screen" rel="stylesheet" type="text/css">
<link href="./stylesheets/pygments.css" media="screen" rel="stylesheet" type="text/css">
<link href="./entries.rss" rel="alternate" title="RSS" type="application/rss+xml">
<link href="http://coderwall.com/stylesheets/jquery.coderwall.css" media="all" rel="stylesheet" type="text/css">
<script src="./javascripts/jquery.js"></script><script src="http://coderwall.com/javascripts/jquery.coderwall.js"></script>
</head>
<body>
<header id="header"><h1>
<a href="./index.html">Joy Luck Crab</a>
</h1>
<nav><ul id="menu">
<li>
<a href="./index.html">Home</a>
</li>
<li>
<a href="./profile.html">Profile</a>
</li>
<li>
<a href="./entries.html">Archives</a>
</li>
<li>
<a href="./entries.rss" target="_blank">RSS</a>
</li>
</ul></nav></header><div id="page">
<div id="content">
<div class="autopagerize_page_element" id="entries">
<article class="article"><h1 class="date">
<a href="./entries/20120328.html">2012-03-28</a>
</h1>
<h1 id="a0">
<a href="./entries/20120328/a0.html">記号がうまく入力できない</a>
</h1>
<p>感覚でキーボードを使うという悪癖が抜けないので、特に苦手な記号の入力を克服するべくコンソールで練習するためのプログラムを書くことにした。</p>
<p><a href="https://github.com/hibariya/kigou">kigou</a></p>
<p>ついでに実装は男らしい感じのコードにしようと思ったけどあまりうまくいかなくて、ただの汚いコードになった。</p>
</article><article class="article"><h1 class="date">
<a href="./entries/20120326.html">2012-03-26</a>
</h1>
<h1 id="a0">
<a href="./entries/20120326/a0.html">プロセスをforkするときのこと</a>
</h1>
<p>孤児プロセスとゾンビプロセスの違いがうまく理解できてなかったけど、ようやく違いを確認することができた。</p>
<h2>孤児プロセス</h2>
<p>孤児プロセスは、親プロセスがwaitせずに先に逝ってしまった後も走り続けている子プロセス。
Orphan Process とも呼ばれる。
親のいなくなった子プロセスはinitプロセスの子（孤児）になる。</p>
<p>親プロセスが死んで、子プロセスの親が変化する様子を見るには以下のようなスクリプトを実行したあとでファイルをtailすると分かりやすそう。</p>
<div class="highlight">
<pre><span class="no">Process</span><span class="o">.</span><span class="n">fork</span> <span class="k">do</span>
  <span class="no">File</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">'orphan'</span><span class="p">,</span> <span class="s1">'a'</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">f</span><span class="o">|</span>
    <span class="kp">loop</span> <span class="k">do</span>
      <span class="nb">sleep</span> <span class="mi">1</span>

      <span class="c1"># 親プロセスのpidをファイルに書き出す</span>
      <span class="n">f</span><span class="o">.</span><span class="n">puts</span> <span class="no">Process</span><span class="o">.</span><span class="n">ppid</span>
      <span class="n">f</span><span class="o">.</span><span class="n">flush</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="nb">sleep</span> <span class="mi">5</span>
</pre>
</div>
<p>このプログラムを実行して、<code>orphan</code>を<code>tail -f</code>で観察していると、5秒後に親プロセスが死んで、子プロセスの親プロセスがinitに変化していることを確認できる。</p>
<div class="highlight">
<pre>$ tailf orphan
80361 # まだ親プロセスの子
80361
80361
80361
80361
1     # ここでinitの養子になってる
1
1
1
</pre>
</div>
<p>initは孤児プロセスをwaitしてくれる。</p>
<h2>ゾンビプロセス</h2>
<p>ゾンビプロセスは、既に処理を終えて死んだ子プロセスが、まだ生きている親プロセスにwaitされるのを待っている状態のこと。</p>
<p>子プロセスが死んでも親プロセスが生きている限り、いつ子プロセスの終了ステータスが参照されても（waitされても）いいように、その情報はプロセステーブルのエントリとして残る。
プロセスとしては死んでいるけれど、waitされるかもしれないのでプロセステーブルに残っている状態がゾンビ。</p>
<div class="highlight">
<pre><span class="nb">puts</span> <span class="no">Process</span><span class="o">.</span><span class="n">fork</span> <span class="p">{</span> <span class="nb">sleep</span> <span class="mi">1</span> <span class="p">}</span>

<span class="nb">sleep</span> <span class="mi">10</span>
</pre>
</div>
<p>上のプログラムを実行して、表示されたpidを元に、別の端末でプロセスの状態を確認すると、ゾンビ状態になっていることがわかる（10秒後には親プロセスが死ぬのでゾンビも消える）。</p>
<div class="highlight">
<pre>$ ps -ho pid,state 81793
  PID STAT
  82077 Z+
</pre>
</div>
<p>ゾンビプロセスの発生を防ぐには、親プロセスで確実にwaitする必要がある。
RubyならProcess.waitpidを使うといい。
waitすると子プロセスが終了するまで親プロセスの処理がブロックされる。</p>
<div class="highlight">
<pre><span class="n">pid</span> <span class="o">=</span> <span class="no">Process</span><span class="o">.</span><span class="n">fork</span> <span class="p">{</span> <span class="nb">sleep</span> <span class="mi">1</span> <span class="p">}</span>

<span class="no">Process</span><span class="o">.</span><span class="n">waitpid</span> <span class="n">pid</span>
</pre>
</div>
<p>もしくは、Double Forkを行うと親プロセスで待たなくてもよくなる。
生成した子プロセスに孫プロセスを生成させ、さらに子プロセスは即座に終了させることで、孫プロセスがinitの子プロセス（孤児プロセス）となってwaitはinitに任せることができるようになる。</p>
<div class="highlight">
<pre><span class="n">pid</span> <span class="o">=</span> <span class="no">Process</span><span class="o">.</span><span class="n">fork</span> <span class="p">{</span>
  <span class="nb">puts</span> <span class="no">Process</span><span class="o">.</span><span class="n">fork</span> <span class="p">{</span>
    <span class="nb">sleep</span> <span class="mi">20</span> <span class="c1"># 何かしらの処理</span>
  <span class="p">}</span>

  <span class="nb">sleep</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="no">Process</span><span class="o">.</span><span class="n">waitpid</span> <span class="n">pid</span>
</pre>
</div>
<h2>まとめ</h2>
<ul>
<li>親が死んだら子はinitが看取ってくれる</li>
<li>親が死ぬまでゾンビは消えない</li>
<li>ゾンビを増やさないためには、適宜waitするかDouble Forkしてinitに面倒をみてもらう</li>
</ul></article><article class="article"><h1 class="date">
<a href="./entries/20120324.html">2012-03-24</a>
</h1>
<h1 id="a0">
<a href="./entries/20120324/a0.html">Retter 0.2.2</a>
</h1>
<p><a href="https://rubygems.org/gems/retter">built-inなテーマにサイドバーをつけました。</a></p>

<h1 id="a1">
<a href="./entries/20120324/a1.html">Retter 0.2.1</a>
</h1>
<p><a href="https://rubygems.org/gems/retter">間を開けずにもう少し変更しました。</a></p>
<h2>複数のテンプレートエンジンへの対応</h2>
<p><a href="https://github.com/rtomayko/tilt">Tilt</a>を使うことで複数のテンプレートエンジンに対応できるようになりました。
ERBとかが使えるようになります。</p>
<h2>固定ページの生成抑止</h2>
<p>以下のページは、使い方によっては必ずしも必要のないページなので、設定すれば生成されないようになりました。</p>
<ul>
<li>profile.html</li>
<li>entries.html</li>
<li>feed.rss</li>
</ul>
<p>ページの生成を抑止する例です。Retterfileに追記します。</p>
<div class="highlight">
<pre><span class="c1"># prfile, entries, feed すべてを生成しない</span>
<span class="n">allow_binding</span> <span class="ss">:none</span>

<span class="c1"># entries, feedは生成する</span>
<span class="n">allow_binding</span> <span class="o">[</span><span class="ss">:entries</span><span class="p">,</span> <span class="ss">:feed</span><span class="o">]</span>
</pre>
</div>
<h2>日付指定の方法</h2>
<p><a href="https://github.com/mojombo/chronic">Chronic</a>を使うようになったので、今までより多くの方法で日付の指定ができるようになりました。
<code>retter edit this\ wednesday</code>とか指定できます。</p>
</article><article class="article"><h1 class="date">
<a href="./entries/20120323.html">2012-03-23</a>
</h1>
<h1 id="a0">
<a href="./entries/20120323/a0.html">Retter 0.2.0</a>
</h1>
<p><a href="https://rubygems.org/gems/retter">Retter</a>をアップデートしました。</p>
<p>Pygmentsを利用できるようになりました。
利用するにはRetterfileに以下の設定を追加します。</p>
<div class="highlight">
<pre><span class="n">renderer</span> <span class="no">Retter</span><span class="o">::</span><span class="no">Renderers</span><span class="o">::</span><span class="no">PygmentsRenderer</span>
</pre>
</div>
<p>今度から<code>retter new</code>するとデフォルトでPygmentsを使用するようになって、そのためのCSSも生成するようになりました。</p>
<p>現状の日記にCSSを追加するには、<a href="https://raw.github.com/hibariya/retter/master/lib/retter/generator/skel/stylesheets/pygments.css">ここ</a>から直接ダウンロードするとすぐに使えるかと思います。</p>
<p>実は、上記の<code>renderer</code>にはRedcarpet::Render::HTMLを継承したクラスであれば何でも指定できます。
Pygmentsを使いたいけどPygments.rbが落ちて困るという場合はAlbinoを使うrendererを作るといいかもしれません。
以下はRedcarpetのREADMEから抜粋したもの。</p>
<div class="highlight">
<pre><span class="k">class</span> <span class="nc">HTMLwithAlbino</span> <span class="o">&lt;</span> <span class="no">Redcarpet</span><span class="o">::</span><span class="no">Render</span><span class="o">::</span><span class="no">HTML</span>
  <span class="k">def</span> <span class="nf">block_code</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">language</span><span class="p">)</span>
    <span class="no">Albino</span><span class="o">.</span><span class="n">safe_colorize</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">language</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>
</div>
<p>それから、Markdownのレンダリング結果をキャッシュするようになりました。
途中でrendererを変更したりして、レンダリング結果が変わるような場合は以下のように<code>tmp/cache</code>以下のキャッシュを一度削除してください。</p>
<div class="highlight">
<pre>rm -rf tmp/cache/*
</pre>
</div>
</article><article class="article"><h1 class="date">
<a href="./entries/20120321.html">2012-03-21</a>
</h1>
<h1 id="a0">
<a href="./entries/20120321/a0.html">Rubyで日付っぽい文字列を日時や日付に変換するときのこと</a>
</h1>
<p>　<a href="https://github.com/mojombo/chronic">Chronic</a>べんり。別に最近のものでもないのだけど、しらなかった。</p>
<p>　それまではActiveSupportで頑張っていた。</p>
<div class="highlight">
<pre><span class="nb">require</span> <span class="s1">'active_support/core_ext/object'</span>
<span class="nb">require</span> <span class="s1">'date'</span>

<span class="k">def</span> <span class="nf">parse_date_str</span><span class="p">(</span><span class="n">date_str</span><span class="p">)</span>
  <span class="k">case</span> <span class="n">date_str</span>
  <span class="k">when</span> <span class="sr">/^yesterday$/i</span> <span class="k">then</span> <span class="mi">1</span><span class="o">.</span><span class="n">day</span><span class="o">.</span><span class="n">ago</span>
  <span class="k">when</span> <span class="sr">/^today$/i</span>     <span class="k">then</span> <span class="mi">0</span><span class="o">.</span><span class="n">day</span><span class="o">.</span><span class="n">ago</span>
  <span class="k">when</span> <span class="sr">/^tomorrow$/i</span>  <span class="k">then</span> <span class="mi">1</span><span class="o">.</span><span class="n">day</span><span class="o">.</span><span class="n">since</span>
  <span class="k">when</span> <span class="sr">/^[0-9]+[\.\s](?:days?|weeks?|months?|years?)[\.\s](?:ago|since)$/i</span>
    <span class="nb">eval</span><span class="p">(</span><span class="n">date_str</span><span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="sr">/\s+/</span><span class="p">,</span> <span class="s1">'.'</span><span class="p">))</span>
  <span class="k">else</span>
    <span class="no">Date</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">date_str</span><span class="p">)</span>
  <span class="k">end</span><span class="o">.</span><span class="n">to_date</span>
<span class="k">end</span>

<span class="n">parse_date_str</span> <span class="s1">'20110101'</span>   <span class="c1"># =&gt; Sat, 01 Jan 2011</span>
<span class="n">parse_date_str</span> <span class="s1">'yesterday'</span>  <span class="c1"># =&gt; Tue, 20 Mar 2012</span>
<span class="n">parse_date_str</span> <span class="s1">'1 week ago'</span> <span class="c1"># =&gt; Wed, 14 Mar 2012</span>
</pre>
</div>
<p>　こんなコード書かなくてもよかったんだ！</p>
<div class="highlight">
<pre><span class="nb">require</span> <span class="s1">'date'</span>
<span class="nb">require</span> <span class="s1">'chronic'</span>

<span class="k">def</span> <span class="nf">parse_date_str</span><span class="p">(</span><span class="n">date_str</span><span class="p">)</span>
  <span class="p">(</span><span class="no">Chronic</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">date_str</span><span class="p">)</span> <span class="o">||</span> <span class="no">Date</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">date_str</span><span class="p">))</span><span class="o">.</span><span class="n">to_date</span>
<span class="k">end</span>

<span class="n">parse_date_str</span> <span class="s1">'20110101'</span>   <span class="c1"># =&gt; #&lt;Date: 2011-01-01 ((2455563j,0s,0n),+0s,2299161j)&gt;</span>
<span class="n">parse_date_str</span> <span class="s1">'yesterday'</span>  <span class="c1"># =&gt; #&lt;Date: 2012-03-20 ((2456007j,0s,0n),+0s,2299161j)&gt;</span>
<span class="n">parse_date_str</span> <span class="s1">'1 week ago'</span> <span class="c1"># =&gt; #&lt;Date: 2012-03-14 ((2456001j,0s,0n),+0s,2299161j)&gt;</span>
</pre>
</div>
<p>　Chronicはparseできなかったときはnilを返す。
Date.parseを残しているのは、YYYYMMDDみたいな形式も使いたかったからで、それを除けばだいたいChronicだけで充分だった。</p>
<p>　戻り値の見た目（Date#inspect）が違うのはActiveSupportの拡張っぽい。</p>
</article><div class="nav">
<div class="next">
<link href="./entries/20120317.html" rel="next">
</div>
</div>
<div class="autopagerize_insert_before"></div>
</div>
</div>
<aside id="sidebar"><h3>Author</h3>
<div class="author">
<a href="./profile.html">hibariya</a>
</div>
<h3>Recent entries</h3>
<div class="recent-entries">
<ul>
<li>
<a href="./entries/20120328/a0.html">記号がうまく入力できない</a>
</li>
<li>
<a href="./entries/20120326/a0.html">プロセスをforkするときのこと</a>
</li>
<li>
<a href="./entries/20120324/a0.html">Retter 0.2.2</a>
</li>
<li>
<a href="./entries/20120324/a1.html">Retter 0.2.1</a>
</li>
<li>
<a href="./entries/20120323/a0.html">Retter 0.2.0</a>
</li>
<li>
<a href="./entries/20120321/a0.html">Rubyで日付っぽい文字列を日時や日付に変換するときのこと</a>
</li>
<li>
<a href="./entries/20120317/a0.html">Rubyでコードブロックに色を付けるときのこと</a>
</li>
</ul>
<div class="archives">
<a href="./entries.html">Archives</a>
</div>
</div>
<h3>Coderwall</h3>
<section class="coderwall" data-coderwall-orientation="horizontal" data-coderwall-username="hibariya"></section></aside>
</div>
<footer id="footer">
Joy Luck Crab (C) hibariya
Generated by
<a href="https://github.com/hibariya/retter" target="_blank">Retter</a>
</footer>
</body>
</html>

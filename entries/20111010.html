<!DOCTYPE html>
<html>
<head>
<title>2011-10-10 - Joy Luck Crab</title>
<meta charset='utf-8' />
<meta content='hibariya' name='author' />
<link href='/favicon.png' rel='icon' type='image/png' />
<link href="/images/favicon.ico" rel="shortcut icon" type="image/vnd.microsoft.icon" />
<link href="/assets/application-a673872ce4e037479417b087073422d2.css" media="all" rel="stylesheet" />
<link href="http://coderwall.com/stylesheets/jquery.coderwall.css" media="all" rel="stylesheet" />
<link href="http://hibariya.github.com/entries.rss" rel="alternate" title="RSS" type="application/rss+xml" />
<script src="/assets/jquery-b89b172fc56a912408007bcc5c0f8370.js"></script>
<script src="http://coderwall.com/javascripts/jquery.coderwall.js"></script>
</head>
<body>
<header id='header'>
<h1>
<a href="/index.html">Joy Luck Crab</a>
</h1>
<nav>
<ul id='menu'>
<li><a href="/index.html">Home</a></li>
<li><a href="/about.html">About</a></li>
<li><a href="/entries.html">Archives</a></li>
<li><a href="/entries.rss" target="_blank">Feed</a></li>
</ul>
</nav>
</header>
<div id='page'>
<div id='content'><article class='article'>
<h1 class='date'><a href="/entries/20111010.html">2011-10-10</a></h1>
<h1 class='retter_entry_article' id='retter_entry_article_20111010a0'>
<a href="/entries/20111010/a0.html">Rubyのトップレベルについて整理する</a>
</h1>
<p>トップレベルでメソッドを定義したとき、なぜそれがいきなり使えるようになるのかを説明できなかったので調べたり人にきいたりした。</p><h2>メソッドについての理解（インスタンスメソッド）</h2><p>クラス定義式の中で（特異メソッドでない）メソッドを定義すると、メソッドはそのクラスのインスタンスメソッドメソッドになる。</p><pre class="highlight ruby">  <span class="k">class</span> <span class="nc">Foo</span>&#x000A;    <span class="k">def</span> <span class="nf">bar</span>&#x000A;      <span class="s1">'bar'</span>&#x000A;    <span class="k">end</span>&#x000A;  <span class="k">end</span>&#x000A;&#x000A;  <span class="no">Foo</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">bar</span> <span class="c1"># =&gt; "bar"</span></pre><p>同じような方法でトップレベルにメソッドを定義すると、なぜかその場で使えるようになる。</p><pre class="highlight ruby"><span class="k">def</span> <span class="nf">bar</span>&#x000A;  <span class="s1">'bar'</span>&#x000A;<span class="k">end</span>&#x000A;&#x000A;<span class="n">bar</span> <span class="c1"># =&gt; "bar"</span></pre><p>もちろん、同じようなことはクラス定義式内ではできない。</p><pre class="highlight ruby">  <span class="k">class</span> <span class="nc">Foo</span>&#x000A;    <span class="k">def</span> <span class="nf">baz</span>&#x000A;      <span class="s1">'baz'</span>&#x000A;    <span class="k">end</span>&#x000A;&#x000A;    <span class="n">baz</span>&#x000A;  <span class="k">end</span> <span class="c1"># =&gt; NameError: undefined local variable or method...</span></pre><p>どうやらクラス定義式の中とトップレベルでは、同じようにメソッド定義式を書いても少し動きが違ってくるらしい。</p><h2>トップレベルで定義されたメソッドは何処へ</h2><p>トップレベルで定義したメソッドについて色々と調べた結果をまとめて書きます。</p><p>クラス定義式の中に書いたメソッドはそのクラスのインスタンスメソッドになった。じゃあトップレベルに定義されたメソッドは何処へ。
実はObjectの（privateな）メソッドになっていた。そしてトップレベルはObjectのインスタンスなので、トップレベルにメソッドを定義すると即座に使えるようになるということらしい。</p><pre class="highlight ruby">  <span class="k">def</span> <span class="nf">carol</span><span class="p">;</span> <span class="k">end</span>&#x000A;&#x000A;  <span class="no">Object</span><span class="p">.</span><span class="nf">private_instance_methods</span><span class="p">.</span><span class="nf">grep</span> <span class="sr">/carol/</span> <span class="c1"># =&gt; [:carol]</span>&#x000A;  <span class="no">Object</span><span class="p">.</span><span class="nf">private_methods</span><span class="p">.</span><span class="nf">grep</span> <span class="sr">/carol/</span>          <span class="c1"># =&gt; [:carol]</span></pre><p>トップレベルで定義したメソッドがどうしてすぐに呼べるのか、言葉のうえでは結論が出た感じになってしまったけれど、話はもう少しだけ続く。</p><h2>Objectの不思議と関数っぽさ</h2><p>Objectに定義されたメソッドは他のクラスに定義されたメソッドとは少し違う動きをする。
なんと、Objectに定義されたメソッドはObjectのクラスメソッドとしても定義される。しかもクラスメソッドにはprivateとかの呼び出し制限もそのまま引き継がれる。</p><pre class="highlight ruby">  <span class="k">class</span> <span class="nc">Object</span>&#x000A;    <span class="k">def</span> <span class="nf">bob</span>&#x000A;      <span class="s1">'ボブですよ'</span>&#x000A;    <span class="k">end</span>&#x000A;  <span class="k">end</span>&#x000A;&#x000A;  <span class="no">Object</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">bob</span> <span class="c1"># =&gt; "ボブですよ"</span>&#x000A;  <span class="no">Object</span><span class="p">.</span><span class="nf">bob</span>     <span class="c1"># =&gt; "ボブですよ"</span>&#x000A;  <span class="n">bob</span>            <span class="c1"># =&gt; "ボブですよ"</span></pre><p>なぜだろう。なぜならObjectはClassのインスタンスだけど、同時にObject（のサブクラス）のインスタンスでもあるから、らしい。
堂々巡りで混乱してくる。</p><pre class="highlight ruby">  <span class="no">Object</span><span class="p">.</span><span class="nf">class</span>           <span class="c1"># =&gt; Class</span>&#x000A;  <span class="no">Object</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">ancestors</span> <span class="c1"># =&gt; [Class, Module, Object, Kernel, BasicObject]</span>&#x000A;  <span class="no">Object</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Object</span><span class="p">)</span>   <span class="c1"># =&gt; true</span></pre><p>でもこの振舞いのおかげで、トップレベルに定義したメソッドはどこでも使えるようになる。何処に居ようがselfの祖先はObjectだから。</p><p>こんなふうに。</p><pre class="highlight ruby">  <span class="k">def</span> <span class="nf">alice</span>&#x000A;    <span class="nb">puts</span> <span class="s1">'hi'</span>&#x000A;  <span class="k">end</span>&#x000A;&#x000A;  <span class="k">class</span> <span class="nc">Bar</span>&#x000A;    <span class="n">alice</span> <span class="c1"># "hi"と表示</span>&#x000A;&#x000A;    <span class="k">def</span> <span class="nf">foo</span>&#x000A;      <span class="n">alice</span>&#x000A;    <span class="k">end</span>&#x000A;&#x000A;    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">foo</span>&#x000A;      <span class="n">alice</span>&#x000A;    <span class="k">end</span>&#x000A;  <span class="k">end</span>&#x000A;&#x000A;  <span class="k">module</span> <span class="nn">BarBar</span>&#x000A;    <span class="n">alice</span> <span class="c1"># "hi"と表示</span>&#x000A;  <span class="k">end</span>&#x000A;&#x000A;  <span class="no">Bar</span><span class="p">.</span><span class="nf">foo</span>     <span class="c1"># "hi"と表示</span>&#x000A;  <span class="no">Bar</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">foo</span> <span class="c1"># "hi"と表示</span>&#x000A;&#x000A;  <span class="n">alice</span>       <span class="c1"># "hi"と表示</span></pre><p>もちろん、Object.#aliceはprivateメソッドなので、<code>self.alice</code>とか<code>Object.alice</code>と書くと例外NoMethodErrorが発生する。
レシーバを記述しない関数風の呼び方が強く奨められているのは、モジュール関数と同じく、関数っぽい使い方をすることが想定されているからなのでしょうね。</p>
</article>
</div>
<aside id='sidebar'>
<h3>Author</h3>
<div class='author'><a href="/about.html">hibariya</a></div>
<h3>Recent entries</h3>
<div class='recent-entries'>
<ul>
<li>
<a href="/entries/20140216/a0.html">Installing Gentoo linux with UEFI boot</a>
</li>
<li>
<a href="/entries/20140215/a0.html">Rewriting Retter gem</a>
</li>
<li>
<a href="/entries/20130418/a0.html">春から学生になった</a>
</li>
<li>
<a href="/entries/20130218/a0.html">東京競馬場へ馬をみにいった</a>
</li>
<li>
<a href="/entries/20130105/a0.html">reditor gem を更新した</a>
</li>
<li>
<a href="/entries/20130105/a1.html">cline gem を更新した</a>
</li>
</ul>
<div class='archives'><a href="/entries.html">Archives</a></div>
</div>
<h3>Coderwall</h3>
<div class='coderwall' data-coderwall-orientation='horizontal' data-coderwall-username='hibariya'></div>
</aside>
</div>
<footer id='footer'>
Joy Luck Crab (C) hibariya
Generated by
<a href='https://github.com/hibariya/retter' target='_blank'>Retter</a>
</footer>
</body>
</html>

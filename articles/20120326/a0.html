<!DOCTYPE html>
<html>
  <head>
    <title>プロセスをforkするときのこと - Hibariya</title>
    <meta charset='utf-8'>
    <meta content='hibariya' name='author'>
    <link href='/favicon-f5e12bf5.png' rel='icon' type='image/png'>
    <link href='/articles.xml' rel='alternate' title='Atom' type='application/atom+xml'>
    <link href="../../stylesheets/application-458a848e.css" rel="stylesheet" type="text/css" media="all" />
    <script src="../../javascripts/application-5ad96b48.js" type="text/javascript"></script>
    <link href='http://note.hibariya.org/articles/20120326/a0.html' rel='canonical'>
  </head>
  <body class='articles articles_20120326 articles_20120326_a0'>
    <header>
      <h1>
        <a href="/">Hibariya</a>
      </h1>
      <nav>
        <ul id='menu'>
          <li><a href="/">Home</a></li>
          <li><a href="../../articles.html">Articles</a></li>
          <li><a target="_blank" href="https://github.com/hibariya">Github</a></li>
          <li><a target="_blank" href="https://twitter.com/hibariya">Twitter</a></li>
          <li><a target="_blank" href="https://hibariya.org">hibariya.org</a></li>
        </ul>
      </nav>
    </header>
    <main>
      <article>
        <time>2012-03-26</time>
        <h1><a href="a0.html">プロセスをforkするときのこと</a></h1>
        <p>孤児プロセスとゾンビプロセスの違いがうまく理解できてなかったけど、ようやく違いを確認することができた。</p>
        
        <h2>孤児プロセス</h2>
        
        <p>孤児プロセスは、親プロセスがwaitせずに先に逝ってしまった後も走り続けている子プロセス。
        Orphan Process とも呼ばれる。
        親のいなくなった子プロセスはinitプロセスの子（孤児）になる。</p>
        
        <p>親プロセスが死んで、子プロセスの親が変化する様子を見るには以下のようなスクリプトを実行したあとでファイルをtailすると分かりやすそう。</p>
        <pre class="highlight ruby"><code><span class="no">Process</span><span class="p">.</span><span class="nf">fork</span> <span class="k">do</span>&#x000A;  <span class="no">File</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="s1">'orphan'</span><span class="p">,</span> <span class="s1">'a'</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">f</span><span class="o">|</span>&#x000A;    <span class="kp">loop</span> <span class="k">do</span>&#x000A;      <span class="nb">sleep</span> <span class="mi">1</span>&#x000A;&#x000A;      <span class="c1"># 親プロセスのpidをファイルに書き出す</span>&#x000A;      <span class="n">f</span><span class="p">.</span><span class="nf">puts</span> <span class="no">Process</span><span class="p">.</span><span class="nf">ppid</span>&#x000A;      <span class="n">f</span><span class="p">.</span><span class="nf">flush</span>&#x000A;    <span class="k">end</span>&#x000A;  <span class="k">end</span>&#x000A;<span class="k">end</span>&#x000A;&#x000A;<span class="nb">sleep</span> <span class="mi">5</span>&#x000A;</code></pre>
        
        <p>このプログラムを実行して、<code>orphan</code>を<code>tail -f</code>で観察していると、5秒後に親プロセスが死んで、子プロセスの親プロセスがinitに変化していることを確認できる。</p>
        <pre class="highlight plaintext"><code>$ tailf orphan&#x000A;80361 # まだ親プロセスの子&#x000A;80361&#x000A;80361&#x000A;80361&#x000A;80361&#x000A;1     # ここでinitの養子になってる&#x000A;1&#x000A;1&#x000A;1&#x000A;</code></pre>
        
        <p>initは孤児プロセスをwaitしてくれる。</p>
        
        <h2>ゾンビプロセス</h2>
        
        <p>ゾンビプロセスは、既に処理を終えて死んだ子プロセスが、まだ生きている親プロセスにwaitされるのを待っている状態のこと。</p>
        
        <p>子プロセスが死んでも親プロセスが生きている限り、いつ子プロセスの終了ステータスが参照されても（waitされても）いいように、その情報はプロセステーブルのエントリとして残る。
        プロセスとしては死んでいるけれど、waitされるかもしれないのでプロセステーブルに残っている状態がゾンビ。</p>
        <pre class="highlight ruby"><code><span class="nb">puts</span> <span class="no">Process</span><span class="p">.</span><span class="nf">fork</span> <span class="p">{</span> <span class="nb">sleep</span> <span class="mi">1</span> <span class="p">}</span>&#x000A;&#x000A;<span class="nb">sleep</span> <span class="mi">10</span>&#x000A;</code></pre>
        
        <p>上のプログラムを実行して、表示されたpidを元に、別の端末でプロセスの状態を確認すると、ゾンビ状態になっていることがわかる（10秒後には親プロセスが死ぬのでゾンビも消える）。</p>
        <pre class="highlight plaintext"><code>$ ps -ho pid,state 81793&#x000A;  PID STAT&#x000A;  82077 Z+&#x000A;</code></pre>
        
        <p>ゾンビプロセスの発生を防ぐには、親プロセスで確実にwaitする必要がある。
        RubyならProcess.waitpidを使うといい。
        waitすると子プロセスが終了するまで親プロセスの処理がブロックされる。</p>
        <pre class="highlight ruby"><code><span class="n">pid</span> <span class="o">=</span> <span class="no">Process</span><span class="p">.</span><span class="nf">fork</span> <span class="p">{</span> <span class="nb">sleep</span> <span class="mi">1</span> <span class="p">}</span>&#x000A;&#x000A;<span class="no">Process</span><span class="p">.</span><span class="nf">waitpid</span> <span class="n">pid</span>&#x000A;</code></pre>
        
        <p>もしくは、Double Forkを行うと親プロセスで待たなくてもよくなる。
        生成した子プロセスに孫プロセスを生成させ、さらに子プロセスは即座に終了させることで、孫プロセスがinitの子プロセス（孤児プロセス）となってwaitはinitに任せることができるようになる。</p>
        <pre class="highlight ruby"><code><span class="n">pid</span> <span class="o">=</span> <span class="no">Process</span><span class="p">.</span><span class="nf">fork</span> <span class="p">{</span>&#x000A;  <span class="nb">puts</span> <span class="no">Process</span><span class="p">.</span><span class="nf">fork</span> <span class="p">{</span>&#x000A;    <span class="nb">sleep</span> <span class="mi">20</span> <span class="c1"># 何かしらの処理</span>&#x000A;  <span class="p">}</span>&#x000A;&#x000A;  <span class="nb">sleep</span> <span class="mi">1</span>&#x000A;<span class="p">}</span>&#x000A;&#x000A;<span class="no">Process</span><span class="p">.</span><span class="nf">waitpid</span> <span class="n">pid</span>&#x000A;</code></pre>
        
        <h2>まとめ</h2>
        
        <ul>
        <li>親が死んだら子はinitが看取ってくれる</li>
        <li>親が死ぬまでゾンビは消えない</li>
        <li>ゾンビを増やさないためには、適宜waitするかDouble Forkしてinitに面倒をみてもらう</li>
        </ul>
      </article>
      <div id='comments'>
        <div id="disqus_thread"></div>
        <script>
          /* * * CONFIGURATION VARIABLES * * */
          var disqus_shortname = 'note-hibariya-org';
          
          /* * * DON'T EDIT BELOW THIS LINE * * */
          (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
        </script>
      </div>
    </main>
  </body>
</html>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  
  ga('create', 'UA-64572851-1', 'auto');
  ga('send', 'pageview');
</script>
